/*
#include <SPI.h>       
#include <DMD.h>       // use SPI bus 
#include <TimerOne.h>
#include "Arial_black_16.h"

#define DISPLAYS_ACROSS 1   // Number of P1 panels in horizontal
#define DISPLAYS_DOWN   1   // Number of P1 panels in vertical
DMD dmd(DISPLAYS_ACROSS, DISPLAYS_DOWN);

const int ledPin = 13;

// Define a struct for your data
struct CommunicationData {
  byte start;
  byte address;
  byte command;
  byte length;
  byte data[3]; // Array to store 3 bytes of data
  byte checksum;
};

void ScanDMD() { 
  dmd.scanDisplayBySPI();
}

void setup() {
  Serial.begin(115200);
  Serial.println("Start...");

  // Initialize TimerOne's interrupt/CPU usage used to scan and refresh the display
  Timer1.initialize(3000);  // period in microseconds to call ScanDMD. Anything longer than 5000 (5ms) and you can see flicker.
  Timer1.attachInterrupt(ScanDMD);  // attach the Timer1 interrupt to ScanDMD which goes to dmd.scanDisplayBySPI()

  pinMode(ledPin, OUTPUT);
}

void loop() {
  // Check if there are bytes available to read from RS485
  if (Serial.available() >= sizeof(CommunicationData)) {
    // Read the bytes into the struct
    CommunicationData receivedData;
    Serial.readBytes((char*)&receivedData, sizeof(CommunicationData));

    // Verify if the received data is valid
    if (receivedData.start == 0xAA && receivedData.checksum == 0x8C && receivedData.length == 3) {
      // Verify if the received command is 0x17 and length is 3
      if (receivedData.command == 0x17 && receivedData.length == 3) {
        // Convert the received data to ASCII characters
        char receivedChars[4]; // Extra byte for null terminator
        for (int i = 0; i < 3; i++) {
          receivedChars[i] = receivedData.data[i];
        }
        receivedChars[3] = '\0'; // Null terminate the string

        // Check if the received data is "123"
        if (strcmp(receivedChars, "123") == 0) {
          // Show "123" on the display
          show_text("123");
        }
      }
    }

    // Send back the received data
    Serial.write((byte*)&receivedData, sizeof(CommunicationData));
  }

  // Continuously read from serial and display the received text
  if (Serial.available() > 0) {
    String incomingString = Serial.readStringUntil('\n');
    show_text(incomingString.c_str());
    delay(2000); // Display the text for 2 seconds
    dmd.clearScreen(true); // Clear the screen after displaying
  }
}

void show_text(const char* text) {
  dmd.clearScreen(true);
  dmd.selectFont(Arial_Black_16);
  dmd.drawString(0, 0, text, strlen(text), GRAPHICS_NORMAL);
}
*/
/*
#include <font/TimesNewRoman12.h> // Include a smaller font

const int ledPin = 13;

DMD3 display;

// Define the structure for communication data
struct CommunicationData {
  byte start;
  byte address;
  byte command;
  byte length;
  byte data[3];
  byte end;
};

byte const arrow1[] PROGMEM = {
  32, 16,
  B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000001, B00000000, B00000000,
  B00000000, B00000011, B00000000, B00000000,
  B00000000, B00000111, B00000000, B00000000,
  B00000000, B00001111, B00000000, B00000000,
  B00000000, B00011111, B11111111, B11100000,
  B00000000, B00111111, B11111111, B11100000,
  B00000000, B01111111, B11111111, B11100000,
  B00000000, B01111111, B11111111, B11100000,
  B00000000, B00111111, B00000000, B00000000,
  B00000000, B00011111, B00000000, B00000000,
  B00000000, B00001111, B00000000, B00000000,
  B00000000, B00000111, B00000000, B00000000,
  B00000000, B00000011, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00000000
};

byte const arrow2[] PROGMEM = {
  32, 16,
  // Define the bitmap data for the second arrow sign here
};


byte const arrow3[] PROGMEM = {
  32, 16,
  // Define the bitmap data for the third arrow sign here
};

const byte* frames[] = {
    arrow1,
   // arrow2,
    //arrow3,
};
#define NUM_FRAMES  (sizeof(frames) / sizeof(frames[0]))
unsigned int frame = 0;

#define ADVANCE_MS  (1000 / NUM_FRAMES)

void scan() {
    display.refresh();
}

void setup() {
  Serial.begin(115200);
  Serial.println("Start...");

  Timer1.initialize(2000);
  Timer1.attachInterrupt(scan);
  Timer1.pwm(9, 255);
}

void loop() {
  byte testData[] = {0xAA, 0x01, 0x17, 0x03, 0x33, 0x32, 0x33, 0x8C};
  int testDataLength = sizeof(testData);

  // Parse testData
  CommunicationData receivedData;
  for (int i = 0; i < sizeof(CommunicationData); i++) {
    ((byte*)&receivedData)[i] = testData[i];
  }

  if (receivedData.start == 0xAA && receivedData.end == 0x8C && receivedData.length == 3) {
    char receivedChars[4];
    for (int i = 0; i < 3; i++) {
      receivedChars[i] = receivedData.data[i];
    }
    receivedChars[3] = '\0';

    // Display data in the serial monitor
    Serial.print("Received Data: ");
    Serial.println(receivedChars);

    // Display arrow and text on the P10 display
    show_text(receivedChars, frames[frame]);
    delay(1000);
    display.refresh();

    frame = (frame + 1) % NUM_FRAMES;
  }

  delay(2000);
  display.clear();
}

void show_text(const char* text, const byte* arrow) {
  display.clear();
  display.setFont(TimesNewRoman12); // Use a smaller font
  display.drawText(10, 0, text); // Adjust the position for text
  display.refresh(); // Refresh the display after drawing text
  delay(2000);
  
  display.clear(); // Clear the display buffer before drawing the arrow
  display.drawBitmap(20, 5, arrow); // Draw arrow at the left side
  display.refresh(); // Refresh the display after drawing arrow
  delay(2000);
}

/*
#include <Arduino.h>
#include "ArrowDisplay.h"

// Create an instance of the ArrowDisplay class
ArrowDisplay arrowDisplay;

void setup() {
  // Initialize the ArrowDisplay
  arrowDisplay.init();
}

void loop() {
  // Show right arrows
  arrowDisplay.showRightArrows();
  delay(1000); // Wait for 1 second between each arrow

  // Show left arrows
  arrowDisplay.showLeftArrows();
  delay(1000); // Wait for 1 second between each arrow
}
*/

// Arial_Black_16.h file code

/*
 *
 * Arial_Black_16
 *
 * created with FontCreator
 * written by F. Maximilian Thiele
 *
 * http://www.apetech.de/fontCreator
 * me@apetech.de
 *
 * File Name           : Arial_black_16.h
 * Date                : 10.01.2012
 * Font size in bytes  : 12422
 * Font width          : 10
 * Font height         : 16
 * Font first char     : 32
 * Font last char      : 128
 * Font used chars     : 96
 *
 * The font data are defined as
 *
 * struct _FONT_ {
 *     uint16_t   font_Size_in_Bytes_over_all_included_Size_it_self;
 *     uint8_t    font_Width_in_Pixel_for_fixed_drawing;
 *     uint8_t    font_Height_in_Pixel_for_all_characters;
 *     unit8_t    font_First_Char;
 *     uint8_t    font_Char_Count;
 *
 *     uint8_t    font_Char_Widths[font_Last_Char - font_First_Char +1];
 *                  // for each character the separate width in pixels,
 *                  // characters < 128 have an implicit virtual right empty row
 *
 *     uint8_t    font_data[];
 *                  // bit field of all characters
 */

#include <inttypes.h>
#include <avr/pgmspace.h>

#ifndef ARIAL_BLACK_16_H
#define ARIAL_BLACK_16_H

#define ARIAL_BLACK_16_WIDTH 10
#define ARIAL_BLACK_16_HEIGHT 16

const static uint8_t Arial_black_16[] PROGMEM = {
    0x30, 0x86, // size
    0x0A, // width
    0x10, // height
    0x20, // first char
    0x60, // char count
    
    // char widths
    0x00, 0x03, 0x07, 0x0B, 0x09, 0x0E, 0x0B, 0x03, 0x05, 0x05, 
    0x06, 0x09, 0x03, 0x05, 0x03, 0x04, 0x08, 0x06, 0x08, 0x08, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x03, 0x03, 0x09, 0x08, 
    0x09, 0x08, 0x0C, 0x0C, 0x09, 0x09, 0x09, 0x09, 0x08, 0x0A, 
    0x0A, 0x03, 0x09, 0x0C, 0x08, 0x0C, 0x0A, 0x0A, 0x09, 0x0A, 
    0x0A, 0x09, 0x0B, 0x0A, 0x0C, 0x10, 0x0C, 0x0B, 0x09, 0x05, 
    0x04, 0x05, 0x08, 0x08, 0x03, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x06, 0x09, 0x09, 0x03, 0x04, 0x0A, 0x03, 0x0D, 0x09, 0x09, 
    0x09, 0x09, 0x06, 0x08, 0x06, 0x09, 0x09, 0x0F, 0x0B, 0x09, 
    0x07, 0x06, 0x02, 0x06, 0x09, 0x08, 
    
    // font data
    0xFE, 0xFE, 0xFE, 0x1D, 0x1D, 0x1D, // 33
    0x1E, 0x1E, 0x1E, 0x00, 0x1E, 0x1E, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 34
    0x30, 0x30, 0xF0, 0xFE, 0x3E, 0x30, 0x30, 0xF0, 0xFE, 0x3E, 0x30, 0x06, 0x1E, 0x1F, 0x07, 0x06, 0x06, 0x1E, 0x1F, 0x07, 0x06, 0x06, // 35
    0x38, 0x7C, 0xFE, 0xE6, 0xFF, 0xC6, 0xCE, 0x8C, 0x0C, 0x04, 0x0C, 0x1C, 0x18, 0x3F, 0x19, 0x1F, 0x0F, 0x07, // 36
    0x3C, 0x7E, 0x42, 0x42, 0x7E, 0x3C, 0x80, 0x60, 0x10, 0x8C, 0x82, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0C, 0x02, 0x01, 0x00, 0x0F, 0x1F, 0x10, 0x10, 0x1F, 0x0F, // 37
    0x00, 0x80, 0x9C, 0xFE, 0xFE, 0xE6, 0xBE, 0x3E, 0x9C, 0x80, 0x80, 0x07, 0x0F, 0x1F, 0x19, 0x18, 0x19, 0x1F, 0x0F, 0x0F, 0x1F, 0x1D, // 38
    0x1E, 0x1E, 0x1E, 0x00, 0x00, 0x00, // 39
    0xE0, 0xF8, 0xFC, 0x1E, 0x02, 0x0F, 0x3F, 0x7F, 0xF0, 0x80, // 40
    0x02, 0x1E, 0xFC, 0xF8, 0xE0, 0x80, 0xF0, 0x7F, 0x3F, 0x0F, // 41
    0x08, 0x68, 0x3E, 0x3E, 0x68, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 42
    0xC0, 0xC0, 0xC0, 0xF8, 0xF8, 0xF8, 0xC0, 0xC0, 0xC0, 0x01, 0x01, 0x01, 0x0F, 0x0F, 0x0F, 0x01, 0x01, 0x01, // 43
    0x00, 0x00, 0x00, 0xDC, 0x7C, 0x3C, // 44
    0x80, 0x80, 0x80, 0x80, 0x80, 0x03, 0x03, 0x03, 0x03, 0x03, // 45
    0x00, 0x00, 0x00, 0x1C, 0x1C, 0x1C, // 46
    0x00, 0x80, 0x78, 0x06, 0x18, 0x07, 0x00, 0x00, // 47
    0xF8, 0xFC, 0xFE, 0x06, 0x06, 0xFE, 0xFC, 0xF8, 0x07, 0x0F, 0x1F, 0x18, 0x18, 0x1F, 0x0F, 0x07, // 48
    0x60, 0x70, 0x38, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, // 49
    0x18, 0x1C, 0x1E, 0x06, 0x86, 0xFE, 0xFC, 0x78, 0x18, 0x1C, 0x1E, 0x1F, 0x1B, 0x19, 0x18, 0x18, // 50
    0x08, 0x1C, 0x1E, 0xC6, 0xC6, 0xFE, 0xFC, 0x38, 0x06, 0x0E, 0x1E, 0x18, 0x18, 0x1F, 0x0F, 0x07, // 51
    0x80, 0xC0, 0xF0, 0x38, 0x1C, 0xFE, 0xFE, 0xFE, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x1F, 0x1F, 0x1F, 0x03, // 52
    0xF0, 0xFE, 0xFE, 0x66, 0x66, 0xE6, 0xC6, 0x86, 0x06, 0x0E, 0x1E, 0x18, 0x18, 0x1F, 0x0F, 0x07, // 53
    0xF0, 0xFC, 0xFE, 0x46, 0x66, 0xEE, 0xCE, 0x8C, 0x03, 0x0F, 0x1F, 0x18, 0x18, 0x1F, 0x0F, 0x07, // 54
    0x06, 0x06, 0x06, 0x86, 0xE6, 0xF6, 0x1E, 0x06, 0x00, 0x00, 0x1C, 0x1F, 0x1F, 0x01, 0x00, 0x00, // 55
    0x38, 0xFC, 0xFE, 0xC6, 0xC6, 0xFE, 0xFC, 0x38, 0x07, 0x0F, 0x1F, 0x18, 0x18, 0x1F, 0x0F, 0x07, // 56
    0x78, 0xFC, 0xFE, 0x86, 0x86, 0xFE, 0xFC, 0xF0, 0x04, 0x0C, 0x1D, 0x19, 0x18, 0x1F, 0x0F, 0x03, // 57
    0x70, 0x70, 0x70, 0x1C, 0x1C, 0x1C, // 58
    0x70, 0x70, 0x70, 0xDC, 0x7C, 0x3C, // 59
    0xE0, 0xE0, 0xE0, 0xF0, 0x70, 0x70, 0x70, 0x38, 0x38, 0x03, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07, 0x0E, 0x0E, // 60
    0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, // 61
    0x38, 0x38, 0x70, 0x70, 0x70, 0xF0, 0xE0, 0xE0, 0xE0, 0x0E, 0x0E, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, 0x03, // 62
    0x18, 0x1C, 0x9E, 0xC6, 0xE6, 0xFE, 0x7C, 0x38, 0x00, 0x00, 0x1D, 0x1D, 0x1D, 0x00, 0x00, 0x00, // 63
    0xE0, 0x18, 0xC4, 0xF4, 0x3A, 0x0A, 0x0A, 0xF2, 0xFA, 0x7C, 0x08, 0xF0, 0x07, 0x18, 0x27, 0x2F, 0x48, 0x48, 0x4C, 0x4F, 0x4F, 0x28, 0x36, 0x11, // 64
    0x00, 0x80, 0xE0, 0xF8, 0xFE, 0x1E, 0xFE, 0xF8, 0xE0, 0x80, 0x00, 0x00, 0x1C, 0x1F, 0x0F, 0x07, 0x06, 0x06, 0x06, 0x07, 0x0F, 0x1F, 0x1C, 0x10, // 65
    0xFE, 0xFE, 0xFE, 0xC6, 0xC6, 0xFE, 0xBC, 0x98, 0x00, 0x1F, 0x1F, 0x1F, 0x18, 0x18, 0x18, 0x1F, 0x0F, 0x07, // 66
    0xF0, 0xFC, 0xFC, 0x0E, 0x06, 0x0E, 0x1E, 0x1C, 0x08, 0x03, 0x0F, 0x1F, 0x1C, 0x18, 0x1C, 0x1F, 0x0E, 0x06, // 67
    0xFE, 0xFE, 0xFE, 0x06, 0x06, 0x0E, 0xFE, 0xFC, 0xF0, 0x1F, 0x1F, 0x1F, 0x18, 0x18, 0x1C, 0x1F, 0x0F, 0x03, // 68
    0xFE, 0xFE, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x06, 0x1F, 0x1F, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, // 69
    0xFE, 0xFE, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x06, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, // 70
    0xF0, 0xFC, 0xFC, 0x0E, 0x06, 0xC6, 0xCE, 0xDE, 0xDC, 0xC8, 0x03, 0x0F, 0x0F, 0x1C, 0x18, 0x18, 0x1C, 0x1F, 0x0F, 0x0F, // 71
    0xFE, 0xFE, 0xFE, 0xC0, 0xC0, 0xC0, 0xC0, 0xFE, 0xFE, 0xFE, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, // 72
    0xFE, 0xFE, 0xFE, 0x1F, 0x1F, 0x1F, // 73
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0x06, 0x0F, 0x1F, 0x1C, 0x18, 0x18, 0x1F, 0x0F, 0x07, // 74
    0xFE, 0xFE, 0xFE, 0xC0, 0xE0, 0xF0, 0xF8, 0xDC, 0x0E, 0x06, 0x02, 0x00, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x01, 0x07, 0x1F, 0x1E, 0x18, 0x10, // 75
    0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, // 76
    0xFE, 0xFE, 0xFE, 0x3E, 0xF8, 0x80, 0x80, 0xF8, 0x3E, 0xFE, 0xFE, 0xFE, 0x1F, 0x1F, 0x1F, 0x00, 0x03, 0x1F, 0x1F, 0x03, 0x00, 0x1F, 0x1F, 0x1F, // 77
    0xFE, 0xFE, 0xFE, 0x7C, 0xF0, 0xE0, 0x80, 0xFE, 0xFE, 0xFE, 0x1F, 0x1F, 0x1F, 0x00, 0x01, 0x03, 0x0F, 0x1F, 0x1F, 0x1F, // 78
    0xF0, 0xFC, 0xFC, 0x0E, 0x06, 0x06, 0x0E, 0xFC, 0xFC, 0xF0, 0x03, 0x0F, 0x0F, 0x1C, 0x18, 0x18, 0x1C, 0x0F, 0x0F, 0x03, // 79
    0xFE, 0xFE, 0xFE, 0xC6, 0xC6, 0xC6, 0xFE, 0x7E, 0x3C, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 80
    0xF0, 0xFC, 0xFC, 0x0E, 0x06, 0x06, 0x0E, 0xFC, 0xFC, 0xF0, 0x03, 0x0F, 0x0F, 0x1C, 0x18, 0x1E, 0x1C, 0x1F, 0x1F, 0x33, // 81
    0xFE, 0xFE, 0xFE, 0xC6, 0xC6, 0xC6, 0xFE, 0x7E, 0x3C, 0x00, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x03, 0x0F, 0x1F, 0x1C, 0x10, // 82
    0x38, 0x7C, 0xFE, 0xE6, 0xE6, 0xEE, 0xDE, 0xDC, 0x98, 0x06, 0x0E, 0x1E, 0x1C, 0x18, 0x19, 0x1F, 0x0F, 0x07, // 83
    0x06, 0x06, 0x06, 0x06, 0xFE, 0xFE, 0xFE, 0x06, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, // 84
    0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0x07, 0x0F, 0x1F, 0x1C, 0x18, 0x18, 0x1C, 0x1F, 0x0F, 0x07, // 85
    0x1E, 0xFE, 0xFC, 0xF0, 0x80, 0x00, 0x80, 0xF0, 0xFC, 0xFE, 0x1E, 0x02, 0x00, 0x00, 0x03, 0x1F, 0x1F, 0x1C, 0x1F, 0x1F, 0x03, 0x00, 0x00, 0x00, // 86
    0xFE, 0xFE, 0xF8, 0x00, 0x80, 0xF8, 0xFE, 0x3E, 0xFE, 0xF8, 0x80, 0x00, 0xF8, 0xFE, 0xFE, 0x06, 0x00, 0x0F, 0x1F, 0x1F, 0x1F, 0x07, 0x01, 0x00, 0x01, 0x07, 0x1F, 0x1F, 0x1F, 0x0F, 0x00, 0x00, // 87
    0x06, 0x1E, 0x3C, 0xF8, 0xF0, 0xE0, 0xF0, 0xF8, 0x3C, 0x1E, 0x06, 0x02, 0x18, 0x1E, 0x0F, 0x07, 0x03, 0x01, 0x03, 0x07, 0x0F, 0x1E, 0x18, 0x10, // 88
    0x02, 0x0E, 0x1E, 0x7E, 0xF8, 0xE0, 0xF8, 0x7E, 0x1E, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, // 89
    0x00, 0x06, 0x06, 0xC6, 0xE6, 0xF6, 0x3E, 0x1E, 0x0E, 0x1C, 0x1E, 0x1F, 0x1B, 0x19, 0x18, 0x18, 0x18, 0x18, // 90
    0xFE, 0xFE, 0xFE, 0x06, 0x06, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, // 91
    0x06, 0x78, 0x80, 0x00, 0x00, 0x00, 0x07, 0x18, // 92
    0x06, 0x06, 0xFE, 0xFE, 0xFE, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, // 93
    0x40, 0x70, 0x7C, 0x1E, 0x1E, 0x7C, 0x70, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 94
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, // 95
    0x02, 0x06, 0x04, 0x00, 0x00, 0x00, // 96
    0x40, 0x60, 0x70, 0x30, 0xB0, 0xB0, 0xF0, 0xF0, 0xE0, 0x0E, 0x1F, 0x1F, 0x1B, 0x19, 0x09, 0x1F, 0x1F, 0x1F, // 97
    0xFE, 0xFE, 0xFE, 0x60, 0x30, 0x30, 0xF0, 0xE0, 0xC0, 0x1F, 0x1F, 0x1F, 0x0C, 0x18, 0x18, 0x1F, 0x0F, 0x07, // 98
    0xC0, 0xE0, 0xF0, 0x70, 0x30, 0x30, 0x70, 0x60, 0x40, 0x07, 0x0F, 0x1F, 0x1C, 0x18, 0x18, 0x1C, 0x0C, 0x04, // 99
    0xC0, 0xE0, 0xF0, 0x30, 0x30, 0x60, 0xFE, 0xFE, 0xFE, 0x07, 0x0F, 0x1F, 0x18, 0x18, 0x0C, 0x1F, 0x1F, 0x1F, // 100
    0xC0, 0xE0, 0xF0, 0xB0, 0xB0, 0xB0, 0xF0, 0xE0, 0xC0, 0x07, 0x0F, 0x1F, 0x1D, 0x19, 0x19, 0x1D, 0x0D, 0x05, // 101
    0x30, 0xFC, 0xFE, 0xFE, 0x36, 0x36, 0x00, 0x1F, 0x1F, 0x1F, 0x00, 0x00, // 102
    0xC0, 0xE0, 0xF0, 0x30, 0x30, 0x60, 0xF0, 0xF0, 0xF0, 0x47, 0xCF, 0xDF, 0xD8, 0xD8, 0xCC, 0xFF, 0x7F, 0x3F, // 103
    0xFE, 0xFE, 0xFE, 0x20, 0x30, 0x30, 0xF0, 0xF0, 0xE0, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, // 104
    0xF6, 0xF6, 0xF6, 0x1F, 0x1F, 0x1F, // 105
    0x00, 0xF6, 0xF6, 0xF6, 0xC0, 0xFF, 0xFF, 0x7F, // 106
    0xFE, 0xFE, 0xFE, 0xC0, 0xE0, 0xF0, 0xF0, 0x30, 0x10, 0x00, 0x1F, 0x1F, 0x1F, 0x03, 0x01, 0x07, 0x1F, 0x1E, 0x1C, 0x10, // 107
    0xFE, 0xFE, 0xFE, 0x1F, 0x1F, 0x1F, // 108
    0xF0, 0xF0, 0xF0, 0x20, 0x30, 0xF0, 0xF0, 0xE0, 0x20, 0x30, 0xF0, 0xF0, 0xE0, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x1F, 0x1F, 0x1F, // 109
    0xF0, 0xF0, 0xF0, 0x20, 0x30, 0x30, 0xF0, 0xF0, 0xE0, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, // 110
    0xC0, 0xE0, 0xF0, 0x70, 0x30, 0x70, 0xF0, 0xE0, 0xC0, 0x07, 0x0F, 0x1F, 0x1C, 0x18, 0x1C, 0x1F, 0x0F, 0x07, // 111
    0xF0, 0xF0, 0xF0, 0x60, 0x30, 0x70, 0xF0, 0xE0, 0xC0, 0xFF, 0xFF, 0xFF, 0x0C, 0x18, 0x18, 0x1F, 0x0F, 0x07, // 112
    0xC0, 0xE0, 0xF0, 0x30, 0x30, 0x60, 0xF0, 0xF0, 0xF0, 0x07, 0x0F, 0x1F, 0x18, 0x18, 0x0C, 0xFF, 0xFF, 0xFF, // 113
    0xF0, 0xF0, 0xF0, 0x20, 0x30, 0x10, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, // 114
    0xE0, 0xF0, 0xF0, 0x90, 0x90, 0xB0, 0x30, 0x20, 0x08, 0x19, 0x1B, 0x13, 0x13, 0x1F, 0x1F, 0x0E, // 115
    0x30, 0xFC, 0xFC, 0xFE, 0x30, 0x30, 0x00, 0x0F, 0x1F, 0x1F, 0x18, 0x18, // 116
    0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0x0F, 0x1F, 0x1F, 0x18, 0x18, 0x08, 0x1F, 0x1F, 0x1F, // 117
    0x10, 0xF0, 0xF0, 0xC0, 0x00, 0xE0, 0xF0, 0xF0, 0x10, 0x00, 0x00, 0x07, 0x1F, 0x1C, 0x1F, 0x07, 0x00, 0x00, // 118
    0x10, 0xF0, 0xF0, 0xE0, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0xE0, 0xF0, 0xF0, 0x10, 0x00, 0x00, 0x07, 0x1F, 0x1E, 0x0F, 0x03, 0x00, 0x03, 0x0F, 0x1E, 0x1F, 0x07, 0x00, 0x00, // 119
    0x10, 0x30, 0x70, 0xE0, 0xC0, 0x80, 0xC0, 0xE0, 0x70, 0x30, 0x10, 0x10, 0x18, 0x1E, 0x0F, 0x07, 0x03, 0x07, 0x0F, 0x1E, 0x18, 0x10, // 120
    0x10, 0xF0, 0xF0, 0xC0, 0x00, 0xC0, 0xF0, 0xF0, 0x30, 0xC0, 0xC0, 0xC7, 0xFF, 0xFC, 0x3F, 0x0F, 0x01, 0x00, // 121
    0x30, 0x30, 0x30, 0xF0, 0xF0, 0xF0, 0x30, 0x1C, 0x1E, 0x1F, 0x1B, 0x19, 0x18, 0x18, // 122
    0x00, 0x00, 0xFC, 0xFE, 0xFE, 0x06, 0x03, 0x03, 0x7F, 0xFF, 0xFC, 0xC0, // 123
    0xFE, 0xFE, 0xFF, 0xFF, // 124
    0x06, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0xC0, 0xFC, 0xFF, 0x7F, 0x03, 0x03, // 125
    0xC0, 0xE0, 0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0xC0, 0xE0, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, // 126
    0xF8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0xF8, 0x1F, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F // 127
    
};

#endif

// Arrowdisplay.cpp
#ifndef ARROW_DISPLAY_H
#define ARROW_DISPLAY_H

#include <DMD3.h>

class ArrowDisplay {
public:
    void init();
    void showRightArrows();
    void showLeftArrows();

private:
    static const unsigned int NUM_FRAMES = 3;
    static const unsigned int ADVANCE_MS = 1000 / NUM_FRAMES;
    Bitmap::ProgMem frames[NUM_FRAMES];
};

#endif

// ArrowDisplay.cpp
#include "ArrowDisplay.h"

DMD3 display;

byte const rightArrow1[] PROGMEM = {
    16, 16,
     B00000000, B00000000, 
     B00000000, B00000000,
     B00000001, B00000000,
     B00000011, B00000000,
     B00000111, B00000000,
     B00001111, B00000000,
     B00011111, B11111111,
     B00111111, B11111111,
     B01111111, B11111111,
     B01111111, B11111111,
     B00111111, B00000000,
     B00011111, B00000000,
     B00001111, B00000000,
     B00000111, B00000000,
     B00000011, B00000000,
     B00000000, B00000000,
     B00000000, B00000000,
     B00000000, B00000000,
     B00000000, B00000000,
     B00000000, B00000000,
     B00000000, B00000000,
     B00000000, B00000000
};


byte const rightArrow2[] PROGMEM = {
    16, 16,
    B00000000, B00000000,
    B00000000, B00000000, 
    B00000000, B00000000,
    B00000000, B00000000, 
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000
};

byte const rightArrow3[] PROGMEM = {
   B00000000, B00000000, 
     B00000000, B00000000,
     B00000001, B00000000,
     B00000011, B00000000,
     B00000111, B00000000,
     B00001111, B00000000,
     B00011111, B11111111,
     B00111111, B11111111,
     B01111111, B11111111,
     B01111111, B11111111,
     B00111111, B00000000,
     B00011111, B00000000,
     B00001111, B00000000,
     B00000111, B00000000,
     B00000011, B00000000,
     B00000000, B00000000,
     B00000000, B00000000,
     B00000000, B00000000,
     B00000000, B00000000,
     B00000000, B00000000,
     B00000000, B00000000,
     B00000000, B00000000
};


Bitmap::ProgMem rightArrowFrames[] = {
    rightArrow1,
    rightArrow2,
    rightArrow3,
};

byte const leftArrow1[] PROGMEM = {
    16, 16,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B10000000,
    B00000000, B11000000, 
    B00000000, B11100000,
    B00000000, B11110000,
    B11111111, B11111000,
    B11111111, B11111100, 
    B11111111, B11111110,
    B11111111, B11111110, 
    B00000000, B11111100,
    B00000000, B11111000,
    B00000000, B11110000,
    B00000000, B11100000,
    B00000000, B11000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,  
    B00000000, B00000000, 
    B00000000, B00000000,  
    B00000000, B00000000
};


byte const leftArrow2[] PROGMEM = {
    16, 16,
    B00000000, B00000000,
    B00000000, B00000000, 
    B00000000, B00000000,
    B00000000, B00000000, 
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000
};

byte const leftArrow3[] PROGMEM = {
    16, 16,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B10000000,
    B00000000, B11000000, 
    B00000000, B11100000,
    B00000000, B11110000,
    B11111111, B11111000,
    B11111111, B11111100, 
    B11111111, B11111110,
    B11111111, B11111110, 
    B00000000, B11111100,
    B00000000, B11111000,
    B00000000, B11110000,
    B00000000, B11100000,
    B00000000, B11000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,
    B00000000, B00000000,  
    B00000000, B00000000, 
    B00000000, B00000000,  
    B00000000, B00000000
};

Bitmap::ProgMem leftArrowFrames[] = {
    leftArrow1,
    leftArrow2,
    leftArrow3,
};

unsigned int rightFrame = 0;
unsigned int leftFrame = 0;

unsigned int frame = 0;

void scan() {
    display.refresh();
}

void ArrowDisplay::init() {
    Timer1.initialize(2000);
    Timer1.attachInterrupt(scan);
    Timer1.pwm(9, 255);
}

void ArrowDisplay::showRightArrows() {
    display.clear();
    int x = 16;  // Always start from the first column
    display.drawBitmap(x, 0, rightArrowFrames[rightFrame]);
    delay(ADVANCE_MS);
    display.refresh();

    rightFrame = (rightFrame + 1) % (sizeof(rightArrowFrames) / sizeof(rightArrowFrames[0]));
}


void ArrowDisplay::showLeftArrows() {
    display.clear();
    int x = 0;  // Always start from the first column
    display.drawBitmap(x, 0, leftArrowFrames[leftFrame]);
    delay(ADVANCE_MS);
    display.refresh();

    leftFrame = (leftFrame + 1) % (sizeof(leftArrowFrames) / sizeof(leftArrowFrames[0]));
}


